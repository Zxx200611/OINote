一篇文章有 $n$ 种单词，第 $i$ 种出现了 $A_i$ 次。现在需要将每种单词用一个 $k$ 进制数替换掉，满足：不存在有单词换成的数是另外一个单词换成的数的前缀。

在满足此要求的前提下，使得文章尽量短；在满足文章最短的前提下，使得所有单词被替换成的数中最长的数长度尽量小。

求：最小的文章长度和满足文章长度最小时最长的数的长度最小值。

---

若此题的 $k$ 恒为 $2$，就是一个裸的哈夫曼树。

若 $k$ 为其他数，若仍使用未修改的哈夫曼树，步骤如下：

+ 一开始将所有数推到一个小根堆中。
+ 此堆按照出现次数为第一关键字，已合并次数为第二关键字排序。
+ 每次弹出最小的 $k$ 个数，将它们合并为一个（出现次数为和，已合并次数为最大已合并次数加一）并推回堆中。
+ 最后剩下一个数时即可返回。

但是这么做会有一个问题，如下图所示（$n=8$，$k=3$）：

<img src="H:\Public\Notes\Draft\Contest\XSY-2021-8-11\A-荷马史诗-png1.png" alt="A-荷马史诗-png1" style="zoom:80%;" />

图中 a/b 表示此节点出现次数为 a，已合并次数为 b。

若按照未修改过的哈夫曼树来做，会做出错误答案（黑+红），一种更优的方法为 黑+蓝。



为什么会出现问题呢？原因出在哈夫曼树的贪心方法（合并前 $k$​​ 个小的）上。

此方法可能会将某些数错误地放在了下面，但是上面还有节点的儿子空着，这样一定是不优的。考虑避免这种情况。

什么时候会出现儿子空着？当且仅当某次合并时所剩节点已经不足 $k$ 个。进一步地，就是当不能每次都完美地（$k$ 个点）合并时，也就是 $n-1 \not\equiv 0 \pmod{k-1}$​ 时。（将 $n$ 个点变为 $1$ 个一共需要合掉 $n-1$ 个点，每次（完美）操作需合掉 $k-1$ 个点）

那么就只用在一开始多加入一些出现次数为 $0$（一定不影响答案）的点将 $n$ 补成 $k-1$ 的倍数加 $1$ 即可。（可以理解为将用一些空的节点将其他点挤到更好的位置（上面）去）。

至此此题解决。